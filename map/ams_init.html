<!DOCTYPE html>
<html lang="en">

<head>            
    <meta charset="utf-8">
    <title>IV: Group11</title>
    <script src="https://d3js.org/d3.v5.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <style>
        path {
            fill: none;
            stroke-width: 1px;
            stroke: #222;
        }
        .keys {
            border: 1px solid blue;
            box-sizing: border-box;
            font-size: 12px;
            -webkit-transition-duration: 0.4s; /* Safari */
            transition-duration: 0.4s;
    }
      .keys.selected {
        font-weight: bold;
      }
      #tooltip {
        position: absolute;
        top: 0;
        left: 0;
        background-color: #f0f0f0;
      }
    </style>
</head>

<body>
    <svg width="800" height="600">
        <g id="mapLayer"></g>
    </svg>
    <script type="text/javascript">
        async function choropleth() {
            let svg = d3.select("svg");
            let width = parseInt(svg.attr("width"));
            let height = parseInt(svg.attr("height"));

            let projection = d3.geoAlbers() 
                .center([4.9, 52.366667])
                .parallels([51.5, 51.49])
                .rotate(120)
                .scale(210000)
                .translate([width / 2, height / 2]);

            let path = d3.geoPath()
                .projection(projection);

            // Define a quantized scale to sort data values into buckets of color
            let color = d3.scaleQuantize()
                .range(["#edf8fb",
                    "#b2e2e2",
                    "#66c2a4",
                    "#2ca25f",
                    "#006d2c"
                ]);


            // Load in GeoJSON data
            let json = await d3.json("map.geojson");


            // Load in the agriculture data; 
            let livingData = await d3.csv("score.csv");

            // Set input domain for color scale based on the lowest and highest values in the data
            color.domain([
                d3.min(livingData, function (d) {
                    return d.living_condition_score_2017;
                }),
                d3.max(livingData, function (d) {
                    return d.living_condition_score_2017;
                })
            ]);

            // Convert the data array to an object, so that it's easy to look up
            // data scores by district names
            let dataLookup = {};
            livingData.forEach(function (scoreRow) {
                // d3.csv will read the values as strings; we need to convert them to floats
                dataLookup[scoreRow.district] = parseFloat(scoreRow.living_condition_score_2017);
            });

            // Now we add the data values to the geometry for every district
            json.features.forEach(function (feature) {
                feature.properties.score = dataLookup[feature.properties.district];
            });

            var tooltip = d3.select("body")
                .append("div")
                .attr("id", "tooltip")
                .style("opacity", 0);
            // Bind data and create one path per GeoJSON feature
            d3.select("#mapLayer").selectAll("path")
                .data(json.features)
                .enter()
                .append("path")
                // here we use the familiar d attribute again to define the path
                .attr("d", path)
                .style("fill", function (d) {
                    return color(d.properties.score);
                })
                .attr('district', function (d) {
                    return d.properties.district;
                })
                .style('cursor', 'pointer')
                .on('mouseover', function (d) {
                    tooltip.style("opacity", 1)
                .html(d.properties.district + '<br />'+ "living condition score: "+d.properties[currentKey] + '<br />'+ "safe score: "+d.properties[safe_keys[keys.indexOf(currentKey)]]+'<br />'+ "population stability score: "+d.properties[popu_keys[keys.indexOf(currentKey)]])
                        .style("left", (d3.event.pageX + 10) + "px")
                        .style("top", (d3.event.pageY - 40) + "px");
                    var self = d3.select(this);
                    self.style('fill', 'blue');
                })
                .on('mousemove', function (d) {
                    tooltip
                        .style("left", (d3.event.pageX + 10) + "px")
                        .style("top", (d3.event.pageY - 40) + "px");
                })
                .on('mouseout', function (d, i) {
                    tooltip.style("opacity", 0);
                    var self = d3.select(this);
                    self.transition()
                        .duration(300)
                        .style('fill', function (d, i) {
                            return color(d.properties[currentKey]);
                        });
                })
                .on('click', function (d, i) {
                    var self = d3.select(this);
                    self.style('fill', 'red');
                });
            var clickKey = function () {
                currentKey = d3.select(this).attr('value');
                d3.selectAll('.keys')
                    .classed("selected", function () {
                        return (d3.select(this).attr('value') === currentKey)
                    });
                updateMap();
            }
            // マップの更新
            var updateMap = function () {
                d3.selectAll('path')
                    .transition()
                    .duration(1000)
                    .style('fill', function (d) {
                        return color(d.properties[currentKey]);
                    });
            }

            d3.csv("score.csv", function (rows) {
                keys =['living_condition_score_2014','living_condition_score_2015','living_condition_score_2016','living_condition_score_2017'];
                safe_keys = ['safety_index_2014','safety_index_2015','safety_index_2016','safety_index_2017'];
                popu_keys =['population_stability_score_2014','population_stability_score_2015','population_stability_score_2016','population_stability_score_2017'];
                svg.selectAll('.keys')
                    .data(keys)
                    .enter()
                    .append('text')
                    .attr('class', 'keys')
                    .attr('x', width - 50)
                    .attr('y', function (d, i) {
                        return 10 + i * height /50;
                    })
                    .attr('value', function (d) {
                        return d;
                    })
                    .attr('font-size', 15)
                    .style('cursor', 'pointer')
                    // TODO: show the year buttons
                    .text(function (d,i) {
                        show_year = i+2014;
                        return show_year ;
                    })
                    .on('click', clickKey);

                currentKey = keys[0];
                safe_currentKey = safe_keys[0];
                popu_currentKey = popu_keys[0];
                updateMap();
            });

        };
        choropleth();
    </script>
</body>

</html>